<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Fat Blog</title>
    <link>https://futingfei.github.io/posts/</link>
    <description>Recent content in Posts on Fat Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Nov 2020 15:11:30 +0800</lastBuildDate><atom:link href="https://futingfei.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>为什么用 assert_eq 比较 string 和 &amp;str 会成功？</title>
      <link>https://futingfei.github.io/posts/compare_string_and_str/</link>
      <pubDate>Fri, 20 Nov 2020 15:11:30 +0800</pubDate>
      
      <guid>https://futingfei.github.io/posts/compare_string_and_str/</guid>
      <description>昨天写代码的时候发现用 assert_eq 比较 string 和 &amp;amp;str 会成功，如下：
let s1 = String::from(&amp;#34;hello&amp;#34;); let s2 = &amp;#34;hello&amp;#34;; assert_eq!(s1, s2); 凭直觉来讲，这不应该能通过，因为 string 和 &amp;amp;str 是两种类型，然后我觉得是 assert_eq 这个宏做了特殊处理，于是我又试了一下
let s1 = String::from(&amp;#34;hello&amp;#34;); let s2 = &amp;#34;hello&amp;#34;; assert!(s1 == s2); 发现也没有问题，这说明和 assert_eq 没啥关系，于是我在 reddit 以及 Rust 中文社区提问，一个老哥的回答是：
 String and &amp;amp;str cannot be compared at all, so Rust will look for ways to make the comparison possible. It will find that s1.deref() returns &amp;amp;str which obviously can be compared to &amp;amp;str (because Strings implement Deref&amp;lt;Target=str&amp;gt;) so it will automatically use that.</description>
    </item>
    
    <item>
      <title>最近看的几本科幻</title>
      <link>https://futingfei.github.io/posts/some-sf/</link>
      <pubDate>Mon, 09 Nov 2020 17:52:52 +0800</pubDate>
      
      <guid>https://futingfei.github.io/posts/some-sf/</guid>
      <description>最近几个月不知不觉养成了睡前看科幻的习惯，因为睡前感觉自己比较放空，读科幻的时候代入感就很强，仿佛自己真的进入了那些世界里一样。还有一个好处就是避免自己刷手机，睡前老是想刷手机，一刷手机的话就又睡不够了。
神农后裔 题材是很新颖的，古代传说中的人物会以怎样的科幻形式展开呢，一下子就吸引了我的眼球。但是具体看下来的话，涉及古代人物的篇幅主要是作为开篇伏笔，主干内容中除了借用了几个古姓之外似乎并没有太多与古代传说相关的东西。
另外有些场景，古代和现代的内容处理的不是很和谐就会给我一种诸葛亮开着兰博基尼的奇怪感觉。所以总体来说，这部小说还是有点不满足我的期望的，不过这本小说还没有完结，后续还是值得期待的。
云鲸记 小说内容就和名字一样美。巨大的云鲸流淌着淡金色的血液，凭借着反重力物质，游弋天际，栖于风中，眠于云间。
想到云鲸，我脑海中浮现出了一个场景：夕阳给一团一团的云镶上金色的边，而不远的天空依然是清澈的浅蓝色。如果那些云有生命的话，恐怕就是云鲸的样子吧。
人类向何处去 《人类向何处去》这是一封来自未来的信。以往读的科幻小说中往往人类的形体不会有太多变化，而在这本书里 18 代人类之间的差距差不多和猫咪与人类之前的差距一样大。这并不是小说，因为里面并没有具体的人物，但是可读性却非常的强，我像是在看一部纪录片一样，记录着人类一步步的进化，而进化的过程让人感到真实而恐怖。我感觉自己很难描述这本书，但是它的的确确和其他的科幻不一样，非常值得一读。
群星 《群星》可能是我最近读的科幻中最对我胃口的一部了，也可能因为它比较像三体吧，故事结构、关键概念的设计都感觉能看到三体的影子。其中构造体的设计我非常喜欢，感觉非常的有意思（题外话：构造体感觉很像编程语言的一个概念哈哈哈）。但就是我最喜欢的两个人物的结局我都不是很满意，感觉作者太宠溺女主了，看完了有种想写同人的冲动[捂脸]。
 最近比较关注的作者是阿缺，《神农后裔》和《云鲸记》都是阿缺写的。我关注他的原因是因为他在《星海旅人》后记中的一段话：
 在银河尺度的舞台上，距离和空间再度恢复了它们的庄严，是难以逾越的存在;曾被科技膨胀得忘乎所以的人类，重新成为虫子。
  要去往下一个星球，就要做好永远无法回到故乡的打算。错过了这间酒馆里遇到的人，在十亿星辰里，再碰上的概率就几乎不存在。道路不会有尽头，前方永远是未知。飞船把文明的种子带到陌生的星球，埋下去，又立刻赶往下一个目的地。你在深夜抬头，所有闪烁的群星，都是人类文明的荣光。
  而在这样的背景里，有一个人，搭载着不同的飞船，在每一颗星球留下足迹。他疲倦，但永远兴味盎然; 他渺小，但浩瀚的星云都是他的朋友; 他见过形形色色的人，但孤单的时候，只会掏出一张因老旧而掉帧的液晶照片。
  这是我心中浪漫的极致。
 我读到这段话时十分触动，因为我感觉自己有很长的一段时间的状态都像这段话里描述的人一样，孤单、疲倦但永远兴味盎然。感觉经历的过去就像是曾经游历过的星球，虽然可以看见它们在发光，但是回去似乎是很难很难了。</description>
    </item>
    
    <item>
      <title>想学学 web 开发？来看看这个项目：RealWorld</title>
      <link>https://futingfei.github.io/posts/real-world/</link>
      <pubDate>Sat, 24 Oct 2020 17:49:20 +0800</pubDate>
      
      <guid>https://futingfei.github.io/posts/real-world/</guid>
      <description>最近想学习一下用 Rust 开发 web 应用，以便之后快速搭建 web 服务。程序员嘛，难免偶尔就要搭个网站什么的。
关于框架和语言的选择，我想用 Rust 做后端，React 做前端。用 Rust 作后端因为 Rust 是我目前的主力开发语言，想多用用。本来也想用 Rust 开发前端的，然后也有 Yew 这样比较优秀的 Rust 前端框架，但是想了想 React 的生态，只能说真香了。
在 GitHub 上一番搜索后发现了这个超出我预期的项目：RealWorld
简单描述一下：这个项目的目标是构建一个类似于Medium的博客网站。项目独特的地方在于，可以任意搭配不同语言的前后端，因为前后端都遵循同样的API接口设计。此外，还有一个我很喜欢的点是最终构建的项目功能比较齐全，是一个可以实际使用的产品，但是又没有太复杂。因为有很多的教程或者项目，要么是太简易，以至于当要真正开发一个产品的时候又没什么头绪，要么是太复杂，不容易上手。
我大致翻了一下，感觉大部分我听说过的语言和前后端框架上面都有。下面我放几个 star 比较多：
前端：
后端：
然后我从中选了 React/Redux作为前端以及 Rust/actix 作为后端。
跑了跑这两个项目，运行的过程都非常顺滑，特别是Rust的后端框架，项目结构很清晰，看着非常舒服。配套的东西也都很全，比如postman测试包和运行着的的后端接口。后面准备基于这两个项目改一个产品出来。
感觉这个项目特别适合刚学完一门语言用来练练手。
最后，特意等了几分钟到10月24号了，祝猿/媛们节日快乐，多点头发，少点 Bug，嘿嘿。</description>
    </item>
    
    <item>
      <title>重读精通比特币</title>
      <link>https://futingfei.github.io/posts/mastering-bitcoin/</link>
      <pubDate>Sun, 24 Nov 2019 17:47:13 +0800</pubDate>
      
      <guid>https://futingfei.github.io/posts/mastering-bitcoin/</guid>
      <description>《精通比特币》这本书说实话我就很久很久以前别人就给我推荐过，我也断断续续的看了几次了（好像每次都没有完整的读完）
但是有些概念，总是理解的模模糊糊，特别是我最近读 parity-bitcoin 源码的时候，总会时不时的有一些疑问
就比如隔离见证，虽然之前概念都算勉强知道，但是等到代码层面就有点吃力了
这块石头也该挪走了，我打算配合着 parity-bitcoin 重新精读一遍精通比特币。终极目标可能是在毕业之前能造个比特币客户端的轮子
《精通比特币》的作者 Andreas M. Antonopoulos 是在 2011 年接触到比特币的，但是和许多聪明人一样，他最开始也没有理解这玩意儿，而是隔了几个月再次接触比特币之后才正经开始学，然后一发不可收拾
在2014年《精通比特币》出版之后，这本书逐渐成为了学习区块链的入门首选，算是宝典级的区块链书籍了。值得一提的是，O’Reilly 这套书本来是叫做动物书，但是这本（切叶蚁）和之后出版的《精通以太坊》（蜜蜂）都是以昆虫为封面的
作者在前言里也讲了封面故事，我觉得挺有意思的：
 在群居生物物种中，切叶蚁表现出了高度复杂行为的物种特征。但是，群落中的每一只蚂蚁个体仅仅遵循一些社会互动和化学气味（即信息素）交换的简单规则。维基百科提到：“切叶蚁形成地球上仅次于人类的最为庞大且复杂的动物社会。”实际上，切叶蚁不吃叶子，而是使用叶子制造一种真菌来充当蚁群主要食物来源。意识到了吗？它们在耕作！
  虽然切叶蚁形成的是阶级社会，且依靠蚁后繁衍后代，但是在蚁群中不存在中央集权体制或领导人。通过切叶蚁我们可以看到，群落中数百万成员所展现的高度智能且复杂的行为是社会网络中的个体互动这一性质的凸显。
 题外话：其实我小时候就挺喜欢切叶蚁的，小时候看动物世界，关于蚂蚁我最喜欢的两个画面一个是黑猩猩用树枝弄蚂蚁吃，另一个就是切叶蚁扛着叶子整整齐齐地在森林里浩浩荡荡
区块链的各种入门资料真的是参差不齐，之前犯傻把市面上的区块链的书差不多都买来宿舍堆着，也看了好多网上的资料。但是最后除了让一堆概念冲的头昏脑涨，也感觉没学到个啥。导致我现在看到区块链科普性质的东西就会有点类似于审美疲劳的那种感觉。
所以现在的话，要是让我总结学习经验的话，就两点：
 找到最好的资料 输出式学习  就拿比特币举例
 最好的资料：比特币白皮书、精通比特币、比特币源码 输出式学习：写博客、给别人讲、造轮子  所以之后也会持续在这里写源码阅读和读书笔记的博客。日常一点的文章会放在我的公众号上面：与自己的邂逅。感兴趣可以关注哈哈哈</description>
    </item>
    
    <item>
      <title>什么是双拼输入法？</title>
      <link>https://futingfei.github.io/posts/shuang-pin/</link>
      <pubDate>Sat, 02 Nov 2019 17:29:15 +0800</pubDate>
      
      <guid>https://futingfei.github.io/posts/shuang-pin/</guid>
      <description>什么是双拼输入法？
 双拼是汉语拼音输入法的一种编码方案。相对于全拼而言，使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文单字了。维基百科
 也就是说只用两次击键就可以拼写任何一个汉字。想想 shuang xiang ping等等拼音，对于拼写效率的提高可想而知。
并且双拼的学习成本并不高。可能就只需要一个下午的时间来专门学习，之后就不用刻意练习，大概再过两个星期就可以熟练使用了，然后就再也回不去了_(:зゝ∠)_
我选择的是搜狗输入法，原因是基本上任何流行的操作系统都有搜狗输入法，包括学校机房的XP以及Linux，5秒之内就可以切换到双拼模式，苹果默认的双拼输入法也是搜狗双拼
缺点：
 虽然双拼减少了击键次数，但是也使得智能简拼的效率降低了，以拼写“生活”为例，用全拼拼写sh即可选择   但是用双拼(搜狗)的话，sh就表示sang,所以就不会有相应提示  重码率提高，为了做到任意两个键拼写一个字，所以好几个字母都代表了两个韵母，这就提高重码率。   针对这个问题的解决方法就是辅助码以及拆字辅助码，当然不用也是完全没有问题的，只是要多按几次翻页键
双拼练习网站 链接 参考：
 选择输入法的哲学：兼论双拼的优缺点 做少数派中的少数派：双拼输入快速入门  </description>
    </item>
    
  </channel>
</rss>
